---
title: OpenAI Tools
date: 2025-09-05 16:48:15
permalink: /tools/
categories:
  - 基础知识
tags:
  - 
author: 
  name: xiao_sl
  link: https://github.com/xiaosl-cell
---

## 注意事项

本文档中的所有代码示例假设您已经正确配置了 API 密钥和 BASE_URL 的系统环境变量。如果您还未配置，请参考 [大模型API调用 - 1.5 系统环境变量配置](/api/#_1-5-系统环境变量配置) 章节进行设置。

代码中的 `client = OpenAI()` 将自动从以下环境变量读取配置：
- `OPENAI_API_KEY`：您的 API 密钥
- `OPENAI_BASE_URL`：API 服务地址（可选，默认为 OpenAI 官方地址）

## 1. File Search（文件检索）

### 1.1 核心概念

File Search是基于向量数据库的语义检索工具，通过自动文本分块和嵌入生成技术，支持多文件并行处理与跨文档语义搜索，实现大规模知识库的高效信息查询。

### 1.2 开发流程详解

#### 1.2.1 助手创建

```python
from openai import OpenAI
import time

client = OpenAI()

# 创建助手
assistant = client.beta.assistants.create(
    name="烟草行业助手",
    instructions="你是一个烟草行业的专家，请根据用户的问题与知识库给出专业的回答",
    model="gpt-4o",
    tools=[{"type": "file_search"}],
)
```

#### 1.2.2 上传文件并向量存储

```python
# 创建向量存储库
vector_store = client.beta.vector_stores.create(name="烟草行业解决方案白皮书")

# 文件批量上传
file_paths = ["《烟草行业解决方案白皮书》.pdf"]
file_streams = [open(path, "rb") for path in file_paths]

file_batch = client.beta.vector_stores.file_batches.upload_and_poll(
    vector_store_id=vector_store.id, files=file_streams
)

# 查看处理状态（需包含：in_progress, completed, failed等状态）
print(f"状态：{file_batch.status}，成功：{file_batch.file_counts.completed}")
```

#### 1.2.3 将助手关联知识库

```python
assistant = client.beta.assistants.update(
    assistant_id=assistant.id,
    tool_resources={
        "file_search": {
            "vector_store_ids": [vector_store.id]  # 可关联多个知识库
        }
    }
)
```

#### 1.2.4 对话

```python
thread = client.beta.threads.create(
    messages=[
        {
            "role": "user",
            "content": "案例中做了哪些建设？",
        }
    ]
)

# 运行助手
run = client.beta.threads.runs.create(
    thread_id=thread.id,
    assistant_id=assistant.id
)

# 轮询等待 `run` 处理完成
while True:
    run_status = client.beta.threads.runs.retrieve(thread_id=thread.id, run_id=run.id)
    if run_status.status in ["completed", "failed"]:
        break
    time.sleep(1)

# 获取助手的回答并打印
messages = client.beta.threads.messages.list(thread_id=thread.id)

for message in messages.data:
    print(f"{message.role}: {message.content}")
```

#### 1.2.5 线程级文件附加

在创建话题时，也可以附加一个向量存储到此线程，在此线程上创建运行时，文件搜索工具将查询来自您的助手的 vector_store和线程上向量存储库上的数据，具体写法如下：

```python
# Upload the user provided file to OpenAI
message_file = client.files.create(
    file=open("---------", "rb"), purpose="assistants"
)

# Create a thread and attach the file to the message
thread = client.beta.threads.create(
    messages=[
        {
            "role": "user",
            "content": "------------------",
            # 将新文件附加到消息中
            "attachments": [
                { "file_id": message_file.id, "tools": [{"type": "file_search"}] }
            ],
        }
    ]
)
```
## 2. Code Interpreter（代码解释器）

### 2.1 核心概念

代码解释器是基于沙盒环境的 Python 代码执行工具，它能够将自然语言指令转换成 Python 代码并自动运行，进而实现数学计算、数据分析、文件处理、数据可视化等任务。其内置代码调试与迭代修正能力，显著提升复杂问题的解决效率和准确性。

### 2.2 开发流程详解

#### 2.2.1 上传文件

将待分析文件上传至 OpenAI：

```python
# 上传数据文件（如 Excel）
file = client.files.create(
    file=open("代码解释器测试数据.xlsx", "rb"),
    purpose='assistants'  # 必须指定用途为 assistants
)
```

#### 2.2.2 助手创建并关联

通过配置 code_interpreter 工具创建专用助手，并关联数据文件：

```python
from openai import OpenAI
import time

client = OpenAI()

# 创建助手（绑定代码解释器工具）
assistant = client.beta.assistants.create(
    name="代码解释器助手测试",
    instructions="你是一个代码解释器助手，请根据用户的问题与提供的相关资料给出专业的回答",
    model="gpt-4o",
    tools=[{"type": "code_interpreter"}],  # 启用代码解释器
    tool_resources={
        "code_interpreter": {
            "file_ids": [file.id]  # 关联数据文件（需提前上传）
        }
    }
)
```

#### 2.2.3 创建对话线程

在用户消息中附加文件，并声明使用代码解释器工具：

```python
# 创建对话线程并附加文件
thread = client.beta.threads.create(
    messages=[
        {
            "role": "user",
            "content": "我希望你帮我计算一下这个表格中姓李的人的平均薪资",
            "attachments": [
                {
                    "file_id": file.id,  # 关联文件到当前对话
                    "tools": [{"type": "code_interpreter"}]  # 指定工具类型
                }
            ]
        }
    ]
)
```

#### 2.2.4 运行助手并获取结果

启动代码执行任务，轮询状态直至完成：

```python
# 启动任务运行
run = client.beta.threads.runs.create(
    thread_id=thread.id,
    assistant_id=assistant.id
)

# 轮询检查运行状态
while True:
    run_status = client.beta.threads.runs.retrieve(thread_id=thread.id, run_id=run.id)
    if run_status.status in ["completed", "failed"]:
        break
    time.sleep(1)

# 提取并打印结果
messages = client.beta.threads.messages.list(thread_id=thread.id)
for message in messages.data:
    print(f"{message.role}: {message.content}")
```
## 3. Function Calling（函数调用）

### 3.1 核心概念

Function Calling 是 OpenAI Assistants API 提供的一项功能（现在绝大多数模型都已经支持），允许开发者预先定义一组可供 AI 助手调用的函数。这些函数被描述为结构化的工具，包含名称、用途说明以及 JSON 格式的参数定义。其主要目的是使助手能够在对话过程中，当遇到需要执行特定操作（如查询外部数据、执行实际操作、调用系统接口等）的场景时，不再仅仅依靠纯文本生成回答，而是能够触发这些预定义函数，从而获得精确且结构化的输出。

### 3.2 加减乘除案例

#### 3.2.1 自定义函数

```python
def add(num1, num2):
    return num1 + num2

def sub(num1, num2):
    return num1 - num2

def mul(num1, num2):
    return num1 * num2

def div(num1, num2):
    return num1 / num2 if num2 != 0 else "除数不能为0"

function_map = {
    "add": add,
    "sub": sub,
    "mul": mul,
    "div": div
}
```

#### 3.2.2 创建助手

```python
from openai import OpenAI
import time
import json

client = OpenAI()

assistant = client.beta.assistants.create(
    name="计算器",
    instructions="你是一个计算器，请根据用户的问题结合我定义的函数给出回答",
    model="gpt-4o",
    tools=[
        {
            "type": "function",
            "function": {
                "name": "add",
                "description": "计算两个数的和",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "num1": {
                            "type": "number",
                            "description": "第一个数"
                        },
                        "num2": {
                            "type": "number",
                            "description": "第二个数"
                        }
                    },
                    "required": ["num1", "num2"]
                }
            }
        },
        {
            "type": "function",
            "function": {
                "name": "sub",
                "description": "计算两个数的差",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "num1": {
                            "type": "number",
                            "description": "第一个数"
                        },
                        "num2": {
                            "type": "number",
                            "description": "第二个数"
                        }
                    },
                    "required": ["num1", "num2"]
                }
            }
        },
        {
            "type": "function",
            "function": {
                "name": "mul",
                "description": "计算两个数的乘积",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "num1": {
                            "type": "number",
                            "description": "第一个数"
                        },
                        "num2": {
                            "type": "number",
                            "description": "第二个数"
                        }
                    },
                    "required": ["num1", "num2"]
                }
            }
        },
        {
            "type": "function",
            "function": {
                "name": "div",
                "description": "计算两个数的商",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "num1": {
                            "type": "number",
                            "description": "第一个数"
                        },
                        "num2": {
                            "type": "number",
                            "description": "第二个数"
                        }
                    },
                    "required": ["num1", "num2"]
                }
            }
        }
    ]
)
```

#### 3.2.3 创建会话并等待响应

```python
thread = client.beta.threads.create()
message = client.beta.threads.messages.create(
    thread_id=thread.id,
    role="user",
    content="请根据我的要求按照优先级规则逐步调用函数。3 + 5 * (8 - 2) / 2 等于多少？",
)
print(f"------------------prompt------------------")
print(message.content[0].text.value)

run = client.beta.threads.runs.create_and_poll(
    thread_id=thread.id,
    assistant_id=assistant.id,
)
```

#### 3.2.4 循环处理function_call直至完成

```python
i = 1
while True:
    if run.status == 'requires_action':
        tool_outputs = []
        print(f"------------------第{i}次请求回调tools------------------")
        i = i + 1
        for tool in run.required_action.submit_tool_outputs.tool_calls:
            function_call = function_map.get(tool.function.name)
            if function_call:
                args = json.loads(tool.function.arguments)
                print(f"调用函数{tool.function.name}，参数为{args}")
                result = function_call(
                    num1=float(args["num1"]),
                    num2=float(args["num2"])
                )
                tool_outputs.append({
                    "tool_call_id": tool.id,
                    "output": str(result)
                })

        if tool_outputs:
            try:
                run = client.beta.threads.runs.submit_tool_outputs(
                    thread_id=thread.id,
                    run_id=run.id,
                    tool_outputs=tool_outputs
                )
            except Exception as e:
                print("Failed to submit tool outputs:", e)
                break

    # 检查运行状态
    run = client.beta.threads.runs.retrieve(
        thread_id=thread.id,
        run_id=run.id
    )

    if run.status == 'completed':
        messages = client.beta.threads.messages.list(
            thread_id=thread.id
        )
        print(f"------------------最终回答------------------")
        print(messages.data[0].content[0].text.value)
        break
    elif run.status == 'failed':
        print("Run failed")
        break

    time.sleep(1)
```