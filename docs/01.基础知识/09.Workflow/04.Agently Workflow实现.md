---
title: 4.Agently Workflow实现
date: 2025-12-03 17:49:11
permalink: /pages/b6948f/
categories:
  - 基础知识
  - Workflow
tags:
  - Workflow
  - Agently
  - 翻译
author: 
  name: xiao_sl
  link: https://github.com/xiaosl-cell
---

## 4.1 相关资源

- **Agently官网**：[Agently.cn](https://Agently.cn)
- **Agently Workflow与LangGraph的详细比较**：[点击查看](https://github.com/Maplemx/Agently/blob/main/docs/compared_with_langgraph.md)
- **Agently Workflow详细教程**：[点击查看](https://github.com/Maplemx/Agently/blob/main/docs/workflow.md)

## 4.2 环境准备

```bash
pip install agently
pip install python-dotenv
```

## 4.3 完整实现代码

```python
import Agently
import os
import dotenv

dotenv.load_dotenv()
api_key = os.getenv("OPENAI_API_KEY")

# 将模型请求配置设置到agent工厂，后续工厂创建的agent对象都可以继承这个配置
agent_factory = (
    Agently.AgentFactory()
    .set_settings("current_model", "OpenAI")
    .set_settings("model.OpenAI.model", "gpt-4o")
    .set_settings("model.OpenAI.auth", {"api_key": api_key})
)

# 创建工作流
workflow = Agently.Workflow()


# 定义关键处理节点
## 首次翻译
@workflow.chunk()
def initial_translation(inputs, storage):
    source_lang = storage.get("source_lang")
    target_lang = storage.get("target_lang")
    source_text = storage.get("source_text")

    # 创建一个翻译agent来执行任务
    translate_agent = agent_factory.create_agent()

    # 给翻译agent设置system信息
    translate_agent.set_agent_prompt(
        "role",
        f"You are an expert linguist, specializing in translation from {source_lang} to {target_lang}."
    )

    # 向翻译agent发起翻译任务请求
    translation_1 = (
        translate_agent
        .input(
            f"""This is an {source_lang} to {target_lang} translation, please provide the {target_lang} translation for this text. Do not provide any explanations or text apart from the translation.
                {source_lang}: {source_text}

                {target_lang}:"""
        )
        .start()
    )

    # 保存翻译结果
    storage.set("translation_1", translation_1)
    # 保存翻译agent备用
    storage.set("translate_agent", translate_agent)
    return {
        "stage": "第一次翻译",
        "result": translation_1
    }


## 反思优化
@workflow.chunk()
def reflect_on_translation(inputs, storage):
    source_lang = storage.get("source_lang")
    target_lang = storage.get("target_lang")
    source_text = storage.get("source_text")
    country = storage.get("country", "")
    translation_1 = storage.get("translation_1")

    # 创建一个反思agent来执行任务
    reflection_agent = agent_factory.create_agent()

    # 给反思agent设置system信息
    reflection_agent.set_agent_prompt(
        "role",
        f"You are an expert linguist specializing in translation from {source_lang} to {target_lang}. \
You will be provided with a source text and its translation and your goal is to improve the translation."
    )

    additional_rule = (
        "The final style and tone of the translation should match the style of {target_lang} colloquially spoken in {country}."
        if country != ""
        else ""
    )

    # 向反思agent发起反思任务
    reflection = (
        reflection_agent
        .input(
            f"""Your task is to carefully read a source text and a translation from {source_lang} to {target_lang}, and then give constructive criticism and helpful suggestions to improve the translation. \
{additional_rule}

The source text and initial translation, delimited by XML tags <SOURCE_TEXT></SOURCE_TEXT> and <TRANSLATION></TRANSLATION>, are as follows:

<SOURCE_TEXT>
{source_text}
</SOURCE_TEXT>

<TRANSLATION>
{translation_1}
</TRANSLATION>

When writing suggestions, pay attention to whether there are ways to improve the translation's \n\
(i) accuracy (by correcting errors of addition, mistranslation, omission, or untranslated text),\n\
(ii) fluency (by applying {target_lang} grammar, spelling and punctuation rules, and ensuring there are no unnecessary repetitions),\n\
(iii) style (by ensuring the translations reflect the style of the source text and takes into account any cultural context),\n\
(iv) terminology (by ensuring terminology use is consistent and reflects the source text domain; and by only ensuring you use equivalent idioms {target_lang}).\n\

Write a list of specific, helpful and constructive suggestions for improving the translation.
Each suggestion should address one specific part of the translation.
Output only the suggestions and nothing else."""
        )
        .start()
    )

    # 保存反思结果
    storage.set("reflection", reflection)
    return {
        "stage": "反思结果",
        "result": reflection
    }


## 二次翻译
@workflow.chunk()
def improve_translation(inputs, storage):
    source_lang = storage.get("source_lang")
    target_lang = storage.get("target_lang")
    source_text = storage.get("source_text")
    translation_1 = storage.get("translation_1")
    reflection = storage.get("reflection")

    # 使用保存下来的翻译agent
    translate_agent = storage.get("translate_agent")

    # 直接发起二次翻译任务
    translation_2 = (
        translate_agent
        .input(
            f"""Your task is to carefully read, then edit, a translation from {source_lang} to {target_lang}, taking into
account a list of expert suggestions and constructive criticisms.

The source text, the initial translation, and the expert linguist suggestions are delimited by XML tags <SOURCE_TEXT></SOURCE_TEXT>, <TRANSLATION></TRANSLATION> and <EXPERT_SUGGESTIONS></EXPERT_SUGGESTIONS> \
as follows:

<SOURCE_TEXT>
{source_text}
</SOURCE_TEXT>

<TRANSLATION>
{translation_1}
</TRANSLATION>

<EXPERT_SUGGESTIONS>
{reflection}
</EXPERT_SUGGESTIONS>

Please take into account the expert suggestions when editing the translation. Edit the translation by ensuring:

(i) accuracy (by correcting errors of addition, mistranslation, omission, or untranslated text),
(ii) fluency (by applying {target_lang} grammar, spelling and punctuation rules and ensuring there are no unnecessary repetitions), \
(iii) style (by ensuring the translations reflect the style of the source text)
(iv) terminology (inappropriate for context, inconsistent use), or
(v) other errors.

Output only the new translation and nothing else."""
        )
        .start()
    )

    # 保存二次翻译结果
    storage.set("translation_2", translation_2)
    return {
        "stage": "改善翻译",
        "result": translation_2
    }


# 连接工作块
(
    workflow
    .connect_to("initial_translation")
    .connect_to("reflect_on_translation")
    .connect_to("improve_translation")
    .connect_to("end")
)


# 添加过程输出优化
@workflow.chunk_class()
def output_stage_result(inputs, storage):
    print(f"[{inputs['default']['stage']}]:\n", inputs["default"]["result"])
    print("-" * 80)
    return


(
    workflow.chunks["initial_translation"]
    .connect_to("@output_stage_result")
    .connect_to("reflect_on_translation.wait")
)
(
    workflow.chunks["reflect_on_translation"]
    .connect_to("@output_stage_result")
    .connect_to("improve_translation.wait")
)
(
    workflow.chunks["improve_translation"]
    .connect_to("@output_stage_result")
)

# 启动工作流
result = workflow.start(storage={
    "source_lang": "English",
    "target_lang": "中文",
    "source_text": """I went to the woods because I wished to live deliberately, to front only the essential facts of life, and see if I could not learn what it had to teach, and not, when I came to die, discover that I had not lived. I wanted to live deep and suck out all the marrow of life, to live so sturdily and Spartan-like as to put to rout all that was not life, to cut a broad swath and shave close, to drive life into a corner, and reduce it to its lowest terms."""
})
```
