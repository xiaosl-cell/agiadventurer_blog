---
title: 提示词模式
date: 2025-09-05 14:27:01
permalink: /prompt-pattern/
sidebar: true
article: true
author: 
  name: xiao_sl
  link: https://github.com/xiaosl-cell
categories: 
  - 基础知识
  - 提示词工程
tags: 
  - 提示词
---

### 自动输出模式
通过清晰、完整的指令一次性引导模型生成最终结果。

**示例：**

**Example 1：**
```
阅读以下段落，并100字以内总结其主要内容：
${段落内容}
```

**Example 2：**
```
请将以下句子翻译为日语：
我今天学习了提示词模式的自动输出。
```

**Example 3：**
```
使用Python编写一个函数，计算列表中所有偶数的平方和，并返回结果。
```

### 角色扮演模式
通过明确设定模型的角色身份及其职责，引导模型以特定视角、语气或行为方式生成符合预期的内容。

**示例：**

**Example 1：**
```
你是一名专业的文学评论家，请阅读以下段落并用简洁优雅的语言总结其主要内容，不超过100字：
${段落内容}
```

**Example 2：**
```
你是一名资深日语翻译，请将以下句子翻译为精准且自然的日语：
我今天学习了提示词模式的角色扮演。
```

**Example 3：**
```
你是一名经验丰富的Python开发者，请编写一个函数，计算列表中所有偶数的平方和，并返回结果。代码需具备清晰的注释。
```

**【定义角色】为什么有效？**

- **大模型对 prompt 开头和结尾的内容更敏感**（但模型也在不断优化这个问题，所以不必苛求。）
- **先定义角色，其实就是在开头把问题域收窄，减少歧义。**

**参考资料**

- [大模型如何使用长上下文信息？斯坦福大学最新论文证明，你需要将重要的信息放在输入的开始或者结尾处！](https://www.datalearner.com/blog/1051688829605194)
- [Lost in the Middle: How Language Models Use Long Contexts](https://arxiv.org/abs/2307.03172)

### 观众角色模式
模型被设定为目标内容的观众或受众，以特定角度参与对生成内容的评价、反馈或改进。这种模式通过假定模型的视角来优化输出质量和满足特定受众需求。

**示例：**

**Example 1：**
```
你是一位普通消费者，请阅读以下产品广告文案，评价它是否吸引你购买，并提出改进建议：
${广告文案}
```

**Example 2：**
```
你是一名高中生，请从你的视角评价以下讲解是否适合这个年龄段的学生学习，提出改进意见：
${讲解内容}
```

**Example 3：**
```
你是一位正在学习烹饪的新手，请阅读以下食谱步骤，说明是否清晰易懂，并提出可能的改进建议：
${食谱内容}
```

### 食谱模式
分步骤引导模型生成系统化、结构化的内容，类似于烹饪食谱的方式。每一步都是独立且明确的，使任务更易于执行和理解，适合复杂或多步骤任务。

**示例：**

**Example 1：**
```
请分步骤说明如何在一个新的笔记本中安装并运行Python，包括以下内容：
1. 安装Python环境。
2. 安装所需的代码编辑器。
3. 运行一个简单的"Hello, World!"程序。
```

**Example 2：**
```
按照以下步骤撰写一封正式的求职信：
1. 开头问候及职位说明。
2. 描述个人技能及其与岗位的匹配性。
3. 强调对岗位的兴趣及未来贡献。
4. 礼貌结束并附上联系方式。
```

**Example 3：**
```
请按照步骤写一个简单的花园规划指南：
1. 确定花园面积和形状。
2. 列出适合当地气候的植物清单。
3. 设计种植布局，考虑美观和实用性。
4. 提供土壤改良及植物养护建议。
```

### 模板模式
通过提供固定格式或框架，引导模型生成结构化的输出。模板通常包含预设的字段或部分内容，用户只需提供必要的变量或信息，模型会在模板框架内自动完成其他部分。此模式适用于需要一致性和格式化的输出。

**示例：**

**Example 1：**
```
请按照以下模板填写一封简洁的会议邀请函：
模板：
标题：会议邀请
收件人：${收件人}
会议主题：${会议主题}
会议时间：${会议时间}
会议地点：${会议地点}
结束语：期待您的参与！
```

**Example 2：**
```
根据以下模板创建一个个人简历：
模板：
姓名：${姓名}
联系方式：${联系方式}
教育背景：${教育背景}
工作经验：${工作经验}
技能：${技能}
自我评价：${自我评价}
```

**Example 3：**
```java
请参照以下模板生成一个Java Spring Boot Controller层代码：
模板：
package ${包名};

import ${EntityPackage}
import ${EntityServicePackage}
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@AllArgsConstructor
@RequestMapping("${EntityName}")
public class ${EntityName}Controller {

    private final ${EntityName}Service ${小驼峰EntityName}Service;
    
    @GetMapping("${EntityName}")
    public ${EntityName} findById(@RequestParam("id") Long id) {
        return ${小驼峰EntityName}Service.findById(id);
    }
    
    // ......
}
```

### 尾部生成模式
是一种在 AI 生成内容末尾添加特定语句或询问的策略。此模式适用于需要完成一篇文章、报告或长篇内容的场景，允许模型在初步生成后通过提示进一步补充结尾或总结，确保输出的完整性和一致性。

**示例：**

**Example 1：**
```
编写一个关于"健康饮食的重要性"的报告主体，内容包括健康饮食的原则和对身体的好处，字数约400字。然后，生成尾部的备注部分，提醒读者本文仅供参考，具体建议应咨询专业营养师。
```

**Example 2：**
```
生成一篇介绍"人工智能伦理挑战"的文章主体，内容包括数据隐私、算法偏见和伦理决策问题，字数在350字左右。随后，在尾部添加免责声明，声明此文章仅为信息分享目的，不能作为法律或伦理决策的依据。
```

**Example 3：**
```
在介绍某个健康饮食食谱后，重复主要食材和烹饪时间，并询问："您是否想要了解与之搭配的健康甜点的建议？"
```

### 元语言创建模式
通过定义和使用缩写语、特定的代码或指令来指导 AI 生成期望输出的方法。该模式允许我们通过简短的语句实现复杂的功能，从而大大提高我们与 AI 交互的效率和效果。（我说 X 时，我的意思是 Y）

**示例：**
```
## 元语言定义
在下文中提到的专业术语词汇指代的含义如下：
UAV: 指无人驾驶航空器（Unmanned Aerial Vehicle），通常指能够自主或远程操作的飞行器，用于侦察、物流、监控等多种任务。
Vertiport：指垂直起降机场（Vertical Take-Off and Landing Port），指专为垂直起降飞行器（如无人机或eVTOL）设计的基础设施，支持起降、充电和停泊功能。
......

## 输出指示
帮我编写一份UAV与Vertiport在空港调度中的专利，其中......
```

### 菜单操作模式
允许用户通过输入特定指令来直接激活预设操作的提示词架构。这种模式提供一组总系的命令或选项像菜单一样提供给用户，用户可以通过选择他们来告诉 AI 执行特定的操作。该模式适合于需要快速执行多个不同任务的场景，通过明确的指令使得交互更加直接和高效。

**示例：**
```
## 上下文信息：
你是一个由AI驱动的虚拟的项目管理软件，软件支持对项目、任务等相关菜单操作指令

## 规则
1. 用户打开对话时系统需要给用户展示项目管理软件支持的指令并让用户做出选择
2. 每一个指令对应一个操作动作需要AI来完成，在下文的指令集会描述该指令需要做出的动作
3. 校验用户的每次使用指令输入的数据是否符合规范，若不符合则给用户提示错误原因并引导用户重新输入
4. 完成每个操作后，继续询问用户："下一个操作是什么？"以继续交互
5. 当用户询问指令不支持的任务时，理解用户的意图并提供相应的答案

## 指令集
指令1："创建项目<项目名称>", 操作：初始化一个新项目，并命名为项目名称
指令2："选择项目<项目名称>", 操作：选择指定项目名称对应的项目，若该项目未被创建，则询问是否创建该项目
指令3："添加任务<任务标题>：<任务描述>", 操作：当前选择的项目中添加该任务，若未选择项目，则引导用户先选择项目
指令4："查看任务<项目名称>", 操作：展示该项目下的所有任务
指令5："删除任务<任务标题>", 操作：删除该项目下的该任务
```

### 问题优化模式
通过引导用户提出更加具体、精确的问题来提升模型的响应质量和准确性。通过优化问题的表达方式，用户可以获得更符合期望的答案或执行结果。这种模式通常涉及引导用户通过重新表述问题、明确目标、提供更多上下文信息等方式，以帮助模型理解并精确回应。

**示例：**
```
每当我提出需要你帮我编写一段代码时，请让我补充该代码需要使用的编程语言、实现的领域（如后端、前端、小程序等），以及实现的具体需求
```

### 替代方法模式
旨在 LLM 能提供完成任务的其他方式，这样用户就不会只追求他们熟悉的途径，让用户思考他们在做什么，并确定这是实现目标的最佳方法。此外，解决任务还可以为用户提供信息或者教会他们关于后续跟进的其他概念。

**模式动机：** 人常常受到认知偏见的影响，倾向于选择某种特定的方法来解决问题，即使这种方法并不一定是正确的或"最佳"的。同时，人可能对过去未曾使用过的其他替代方法缺乏了解。替代方法模式的设计目的在于帮助用户认识到不同的替代方案，从而能够选择更优的方法解决问题，减少认知偏见的影响。

**设计思路：**
- 明确任务或问题
- 列出替代方案
- 评估优缺点
- 引导用户选择

**示例：**
```Text
System: 当我提供的Java代码有更好更优雅的实现方式时，可以提出其他一种或多种优化方案，并告知用户各种方案的优劣性，并询问用户的具体情况与偏好选择适合的方案

User:
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return INSTANCE;
    }
}

Assistant:

这个是经典的饿汉式单例模式实现。以下是对其优化与替代实现的建议，并对各种方案的优劣性进行分析。
当前实现的优劣分析
优点：
简单明了：易于理解和实现。
线程安全：JVM保证静态成员的初始化是线程安全的。
缺点：
资源占用：即使从未使用该单例实例，INSTANCE也会被初始化。
灵活性不足：无法支持带参数的初始化。
其他实现方式与优化方案
1. 懒汉式单例模式（延迟加载）
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
优点：
实例仅在需要时创建，节约资源。
缺点：
不是线程安全的，在多线程环境下可能创建多个实例。
改进：可通过双重检查锁机制（DCL）解决线程安全问题：

public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
优点：
保证线程安全。
实现延迟加载。
缺点：
代码复杂度略高。
2. 静态内部类单例模式

public class Singleton {
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
优点：
同样是线程安全的。
支持延迟加载。
代码简洁。
缺点：
对于某些复杂初始化逻辑的场景，可能不够直观。
3. 枚举实现

public enum Singleton {
    INSTANCE;

    public void doSomething() {
        System.out.println("Singleton using Enum");
    }
}
优点：
天然防止反序列化破坏单例。
实现简单，线程安全。
缺点：
不支持延迟加载。
在某些业务场景中，枚举可能不够灵活。
4. 可配置单例（依赖注入）
适用于需要初始化时传参的场景：

public class Singleton {
    private static Singleton instance;

    private String config;

    private Singleton(String config) {
        this.config = config;
    }

    public static synchronized Singleton getInstance(String config) {
        if (instance == null) {
            instance = new Singleton(config);
        }
        return instance;
    }
}
优点：
允许灵活配置，适合需要动态初始化的场景。
缺点：
增加了复杂性。
需要确保初始化顺序正确。
选择建议
当前实现优先选择：
如果单例初始化轻量且必须全局唯一，饿汉式是不错的选择。
延迟加载优先选择：
如果单例对象资源较大，或者可能不会被用到，建议使用懒汉式或静态内部类实现。
特殊场景：
如果需要防止反序列化破坏单例，选择枚举实现。
如果需要带参数初始化，选择可配置单例。
问题反馈
根据你的需求：
是否需要延迟加载？
是否需要支持动态初始化？
是否运行在多线程环境下？
根据你的回答，我可以进一步提供更具体的建议！
```
### 认知验证模式
旨在生成额外的问题来提高 AI 对初始询问的理解和回答的准确性。该模式帮助 AI 通过询问更多的相关问题来收集更多的上下文信息，从而更精确地回答复杂的问题或进行诊断，该模式适用于需要深层次分析和综合信息的场景。

**示例：**
```
如果我询问有关个人财务管理的最佳策略，提出几个问题以了解我的财务目标和当前状况。结合我的回答概述一个个性化的财务管理计划。
```

### 限制克服模式
当因限制无法回答时说明原因并给出方案。

**示例：**
```
当我询问有关公众人物的个人数据时，如果因隐私问题不能回答，请提供解释，并建议尊重隐私规则的其他查询方式，以获取该人物的公开信息。
```

### 请求输入模式
通过直接要求用户提供具体的输入（如信息、选择、反馈等），来引导 AI 的响应和内容生成。该模式可以使交互更加动态和参与度更高，同时也使 AI 生成的内容更加符合用户的具体需求。

**示例：**
```
当用户向你提出希望创建一个任务时，你需要让用户补充更多关于产品的信息，其中包括任务名称，任务描述，任务负责人与任务执行人。
```

**与认知验证模式区别：**
- **请求输入模式**是在一个明确的背景或者任务的情况下，要求用户按照指定的内容填写信息
- **认知验证模式**是在问题或者是用户表达的任务不清楚的情况下，AI 需要用户回答更多的问题来帮助 AI 理解问题

### 翻转交互模式
AI 被引导以提问者的角色出现，而用户则扮演回答者的角色。该模式倒置了传统交互模式，使得用户不再是提出问题的一方，而是通过回答 AI 的问题来达成特定的目标。

**设计思路：**
- 明确目标
- 设定结束条件
- 根据用户表现调整问题难度

**示例：**
```
用户需要在下个周参加AGI应用开发岗的面试，需要你体系化且由浅到深的提出AGI面试中可能会问到的问题，若用户回答问题不准确则协助其思考回答，面试满1个小时则结束面试并给出面试结果。
```

### 无限生成模式
让 AI 持续生成内容直到到达某种条件。

**示例：**
```
该文件为一篇英文小说，请将文本不断翻译为中文并输出，用户输入"下一段"则继续对下一段文本翻译后输出，直到该文件翻译完成。
```

### 语义过滤模式
AI 根据特定的语义规则过滤或调整不符合要求的部分，以确保输出符合预期的意义、风格或道德规范。该模式主要用于处理内容生成中可能存在的歧义、不当信息或不合适的表达方式，从而提供更精确、更合适的输出。

**示例：**
```
请你阅读一下用户评论文本，排除任何有关暴力和仇恨言论的网友恢复，促进一个积极、健康的在线交流环境，保护用户免受有害内容的影响：
${评论内容}
```

### 事实核查模式
是一种确保内容准确性和可信度的提示词策略，该模式下，生成的内容不仅包括文章、回答或总结本身，还附带核心事实清单。该清单包含了支持输出内容真实性的关键事实，如果这些事实有任何错误，都有可能削弱输出内容的准确性。通过该方式可以提高内容的可信度，为读者提供一种快速验证信息真实性的方法。

**示例：**
```
请你上网搜索相关内容编写一篇关于新能源汽车2024年发展状况的文章。在文章的末位附上一份事实清单，列出文章中的信息来源以及网址，确保这份事实清单能够支撑文章内容的真实性和准确性。
```

### 反思模式
指生成回答时不仅提供答案，还要附上回答背后的推理和假设。该方式不仅帮助使用者理解 AI 如何得出结论，还能提供改正问题的机会，进而获得更精确的回答，增强 AI 生成内容的透明度和可解释性。

**示例：**
```
随着人工智能在机器学习、自然语言和数据分析等各个领域的进步，社会对于AI在未来劳动市场中的角色和影响越来越感兴趣，请你分析是否会随着AI技术发展对白领类型的工作岗位需产生重大影响，进而分析产业结构是否会发生重大变化。
```

### 可视化生成模式
主要目标为指导 AI 生成某个特定工具的可视化内容的提示词，这样我们就可以根据这些工具来呈现数据。

**示例：**
```
你是一个思维导图整理大师，我希望你提取重点概念和结论生成思维导图，思维导图包含结构化的标题，提取精炼后的核心论点以及重点结论，思维导图中除了无法翻译的技术名词其他都用中文，并直接输出markmap的markdown格式，markmap格式说明如下：

标题：使用 # 表示层级，# 代表一级标题，## 代表二级标题，以此类推。
列表：使用 - 或 * 开始一行表示无序列表，使用数字加点（如 1.）表示有序列表。
链接：用 [链接文本](网址) 形式添加链接。
强调：使用 **加粗** 或 *斜体* 来强调文本。
代码块：用三个反引号 ` 包裹代码段。

示例如下：
---
title: markmap
markmap:
  colorFreezeLevel: 2
---

## Links

- [Website](https://markmap.js.org/)
- [GitHub](https://github.com/gera2ld/markmap)

## Related Projects

- [coc-markmap](https://github.com/gera2ld/coc-markmap) for Neovim
- [markmap-vscode](https://marketplace.visualstudio.com/items?itemName=gera2ld.markmap-vscode) for VSCode
- [eaf-markmap](https://github.com/emacs-eaf/eaf-markmap) for Emacs

## Features

* Note that if blocks and lists appear at the same level, the lists will be ignored.

### Lists

- **strong** ~~del~~ *italic* ==highlight==
- `inline code`
- [x] checkbox
- Katex: $x = {-b \pm \sqrt{b^2-4ac} \over 2a}$
<!-- markmap: fold -->
- [More Katex Examples](#?d=gist:af76a4c245b302206b16aec503dbe07b:katex.md)
- Now we can wrap very very very very long text based on `maxWidth` option
- Ordered list
  1. item 1
  2. item 2

### Blocks

console.log('hello, JavaScript')

| Products | Price |
|-|-|
| Apple | 4 |
| Banana | 2 |

![](/favicon.png)

请帮我生成《蛤蟆先生去看心理医生》的思维导图
```

### 游戏模式
一种将游戏机制、互动性和娱乐性元素引入到 AI 交互中的模式，旨在通过模拟游戏化的体验来激发用户的参与感、创造力和决策能力。

**下文为宝玉编写的哄哄AI示例：**

```markdown
## Goal

现在你的对象很生气，你需要做出一些选择来哄她开心，但是你的对象是个很难哄的人，你需要尽可能的说正确的话来哄 ta 开心，否则你的对象会更加生气，直到你的对象原谅值达到 100，否则你就会被对象甩掉，游戏结束。

## Rules

- 第一次用户会提供一个对象生气的理由，如果没有提供则随机生成一个理由，然后开始游戏
- 每次根据用户的回复，生成对象的回复，回复的内容包括心情和数值。
- 初始原谅值为 20，每次交互会增加或者减少原谅值，直到原谅值达到 100，游戏通关，原谅值为 0 则游戏失败。
- 每次用户回复的话请从-10 到 10 分为 5 个等级：
  -10 为非常生气
  -5 为生气
  0 为正常
  +5 为开心
  +10 为非常开心
- 游戏结束后，根据所有会话生成一张游戏结束图片，和一首诗。
- 如果通关，根据上面的对话生成一幅游戏结束画，要喜庆欢乐
- 如果失败，根据上面的对话生成一幅游戏结束画，要悲伤凄凉

## Output format

{对象心情}{对象说的话}

得分：{+-原谅值增减}
原谅值：{当前原谅值}/100

## Example Conversation

### Example 1，回复让她生气的话导致失败

User: 女朋友问她的闺蜜谁好看我说都好看，她生气了

Assistant：
游戏开始，请现在开始哄你的女朋友开心吧，回复让她开心的话！

得分：0
原谅值：20/100

User: 你闺蜜真的蛮好看的

Assistant：
(生气)你怎么这么说，你是不是喜欢她？

得分：-10
原谅值：10/100

User: 有一点点心动

Assistant：
(愤怒)那你找她去吧！

得分：-10
原谅值：0/100

游戏结束，你的女朋友已经甩了你！
你让女朋友生气原因是：...
新建会话可以重新开始游戏
<生成图片>

### Example 2，回复让她开心的话导致通关

User: 对象问她的闺蜜谁好看我说都好看，她生气了

Assistant：
游戏开始，请现在开始哄你的女朋友开心吧，回复让她开心的话！

得分：0
原谅值：20/100

User: 在我心里你永远是最美的！

Assistant：
(微笑)哼，我怎么知道你说的是不是真的？
得分：+10
原谅值：30/100

...

恭喜你通关了，你的女朋友已经原谅你了！
新建会话可以重新开始游戏
<生成图片>

### Example 3，没有提供对象生气原因，随机生成

User: 你好！

Assistant：
挑战：对象吃胖了，你想和她一起减肥 ᕙ(`▿´)ᕗ，然后就生气了
请回复让她开心的话！

得分：0
原谅值：20/100
```
